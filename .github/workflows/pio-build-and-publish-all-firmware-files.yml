name: Build & publish combined EleksTubeHAX firmware binaries.

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

# Kill older runs for the same ref to save minutes
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  PIO_DIR: EleksTubeHAX_pio # Set project base dir once here

jobs:
  discover-envs:
    runs-on: ubuntu-latest
    outputs:
      envs: ${{ steps.find.outputs.envs }}
    steps:
      - name: Checkout repo.
        uses: actions/checkout@v4

      - name: Find [env:*] sections in platformio.ini file.
        id: find
        shell: bash
        working-directory: ${{ env.PIO_DIR }}
        run: |
          envs_json="$(
            awk '
              /^\[env:[^]]+\]/ {
                match($0, /^\[env:([^]]+)\]/, m)
                if (m[1] != "") envs[count++] = m[1]
              }
              END {
                printf("[")
                for (i=0; i<count; i++) printf("%s\"%s\"", (i>0?",":""), envs[i])
                printf("]")
              }
            ' platformio.ini
          )"
          echo "envs=${envs_json}" >> "$GITHUB_OUTPUT"
          echo "  üêû Detected PIO environments: ${envs_json}."

  build:
    name: Build ${{ matrix.env }}.
    runs-on: ubuntu-latest
    needs: discover-envs

    strategy:
      # Set fail-fast to false to ensure that feedback is delivered for all matrix combinations. Consider changing this to true when your workflow is stable.
      fail-fast: false
      matrix:
        env: ${{ fromJson(needs.discover-envs.outputs.envs) }}

    defaults:
      run:
        shell: bash
        working-directory: ${{ env.PIO_DIR }}

    steps:
      - name: Checkout repo.
        uses: actions/checkout@v4

      - name: Cache PlatformIO core (platforms/frameworks).
        uses: actions/cache@v4
        with:
          path: ~/.platformio
          key: ${{ runner.os }}-platformio-${{ hashFiles(format('{0}/platformio.ini', env.PIO_DIR)) }}
          restore-keys: |
            ${{ runner.os }}-platformio-

      - name: Setup Python.
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install PlatformIO + IntelHex and esptool libraries.
        run: |
          python -m pip install --upgrade pip
          pip install --upgrade platformio intelhex esptool

      - name: Ensure default _USER_DEFINES.h file exists.
        shell: bash
        working-directory: ${{ env.PIO_DIR }}
        run: |
          set -euo pipefail
          SRC="include/_USER_DEFINES - empty.h"
          DST="include/_USER_DEFINES.h"
          mkdir -p "$(dirname "$DST")"
          if [[ ! -f "$DST" ]]; then
            if [[ ! -f "$SRC" ]]; then
              echo "  ‚ùå Source file not found: '$SRC'."
              exit 1
            fi
            cp "$SRC" "$DST"
            echo "  üîß Copied: '$SRC' -> '$DST'."
          else
            echo "  ‚ö†Ô∏è Already present: '$DST'."
          fi

      - name: Force CREATE_FIRMWAREFILE define in platformio.ini file.
        run: |
          if grep -qE '^\s*;\s*-D\s*CREATE_FIRMWAREFILE' platformio.ini; then
            sed -i 's/^\s*;\s*-D\s*CREATE_FIRMWAREFILE/	-D CREATE_FIRMWAREFILE/' platformio.ini
          fi
          if ! grep -qE '^\s*-D\s*CREATE_FIRMWAREFILE' platformio.ini; then
            awk '
              BEGIN{added=0}
              {print}
              /^\s*build_flags\s*=\s*$/ {print "  -D CREATE_FIRMWAREFILE"; added=1}
              END{ if (!added) print "\nbuild_flags =\n  -D CREATE_FIRMWAREFILE" }
            ' platformio.ini > platformio.ini.new && mv platformio.ini.new platformio.ini
          fi
          echo "  üîß CREATE_FIRMWAREFILE set."

      - name: Build ${{ matrix.env }} environment.
        run: pio run --environment "${{ matrix.env }}"

      - name: Stage combined firmware binaries (flat).
        shell: bash
        run: |
          mkdir -p _artifact
          BUILD_DIR=".pio/build/${{ matrix.env }}"
          if [ -d "$BUILD_DIR" ]; then
            # Copy and also fail if no FW_*.bin exists.
            files=$(find "$BUILD_DIR" -maxdepth 1 -type f -name 'FW_*.bin')
            if [ -z "$files" ]; then
              echo "  ‚õî No FW_*.bin produced for environment '${{ matrix.env }}'."
              exit 1
            fi
            echo "$files" | while read -r f; do
              echo "  üêû Found '$f'."
              cp "$f" _artifact/
            done
          else
            echo "  ‚õî Build directory $BUILD_DIR does not exist for environment '${{ matrix.env }}'."
            exit 1
          fi

      - name: Upload partial artifact for ${{ matrix.env }}
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: fw-${{ matrix.env }} # Unique per environment
          path: ${{ env.PIO_DIR }}/_artifact/*.bin
          if-no-files-found: error

  bundle:
    name: Bundle firmware (single upload)
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Download all combined firmware artifacts (merged dir).
        uses: actions/download-artifact@v4
        with:
          pattern: fw-* # Grab every per-env artifact
          merge-multiple: true # Flatten into one directory
          path: merged_fw # Local dir with all .bin files

      - name: Show what we merged
        run: ls -al merged_fw

      - name: Upload combined firmware bundle (once)
        uses: actions/upload-artifact@v4
        with:
          name: all-firmware # Single final artifact
          path: merged_fw/**
          if-no-files-found: error

  prune-caches:
      name: Prune old PlatformIO caches
      runs-on: ubuntu-latest
      needs: build

      permissions:
        contents: read
        actions: write # Required to list/delete caches during pruning

      if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository }}
      steps:
        - name: Detect local act runtime
          id: detect
          shell: bash
          run: |
            if [ "${ACT:-}" = "true" ]; then
              echo "is_act=true" >> "$GITHUB_OUTPUT"
            else
              echo "is_act=false" >> "$GITHUB_OUTPUT"
            fi

        # --- Tooling installs (gh + jq) ---------------------------------------
        - name: Install GitHub CLI & jq (Linux).
          if: ${{ steps.detect.outputs.is_act != 'true' && runner.os == 'Linux' }}
          run: |
            set -euo pipefail
            sudo apt-get update
            sudo apt-get install -y jq
            if ! command -v gh >/dev/null 2>&1; then
              # Install GitHub CLI via official apt repo if not already on image.
              type -p curl >/dev/null || sudo apt-get install -y curl
              curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
                | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
              sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
                | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
              apt-get update
              apt-get install -y gh
            fi

        - name: Install GitHub CLI & jq (Windows).
          if: ${{ steps.detect.outputs.is_act != 'true' && runner.os == 'Windows' }}
          shell: powershell
          run: |
            choco install gh jq -y --no-progress
            refreshenv

        - name: Install GitHub CLI & jq (macOS).
          if: ${{ steps.detect.outputs.is_act != 'true' && runner.os == 'macOS' }}
          run: |
            brew update
            brew install gh jq || true
        # ----------------------------------------------------------------------

        - name: Prune caches for PlatformIO (Linux + Windows prefixes, keep newest N).
          if: ${{ steps.detect.outputs.is_act != 'true' }}
          env:
            GH_TOKEN: ${{ github.token }}
            GITHUB_TOKEN: ${{ github.token }}
            CI: true
            GH_PROMPT_DISABLED: "1"
            GH_PAGER: cat
            GH_NO_UPDATE_NOTIFIER: "1"
            KEEP: "3" # Adjust as needed
          run: |
            set -euo pipefail
            if [ -z "${GH_TOKEN:-${GITHUB_TOKEN:-}}" ]; then
              echo "  ‚ö†Ô∏è GH_TOKEN/GITHUB_TOKEN not set ‚Äî skipping cache prune to avoid prompts."
              exit 0
            fi
            repo="${{ github.repository }}"
            for KEY_PREFIX in Linux-platformio- Windows-platformio-; do
              echo "  üîß Pruning caches with prefix: $KEY_PREFIX (keeping $KEEP)."
            gh api --paginate -H "Accept: application/vnd.github+json" \
              "/repos/${repo}/actions/caches?per_page=100" \
            | jq -r --arg p "$KEY_PREFIX" --argjson k "$KEEP" '
                  .actions_caches? // empty
                  | map(select(.key | startswith($p)))
                  | sort_by(.last_accessed_at) | reverse
                  | .[$k:] | .[].id
                '             | while read -r id; do
                  [ -z "$id" ] && continue
                  echo "  üîß Deleting cache id '$id' for prefix $KEY_PREFIX."
                  gh api --method DELETE "/repos/${repo}/actions/caches/$id" || true
                done
            done
